// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import {GPO} from "../gpo/GPO.sol";
import {GPX} from "../gpx/GPX.sol";
import {GPOVault} from "../gpovault/GPOVault.sol";
import {IERC20} from "openzeppelin-contracts/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol";
import {PoolKey} from "@uniswap/v4-core/src/types/PoolKey.sol";
import {SafeCast} from "@uniswap/v4-core/src/libraries/SafeCast.sol";
import {SqrtPriceMath} from "@uniswap/v4-core/src/libraries/SqrtPriceMath.sol";
import {LibPRNG} from "solady/utils/LibPRNG.sol";
import {IV4Router} from "v4-periphery/src/interfaces/IV4Router.sol";
import {IUniversalRouter} from "../utils/IUniversalRouter.sol";
import {Commands} from "../utils/Commands.sol";
import {Actions} from "v4-periphery/src/libraries/Actions.sol";
import {IPermit2} from "permit2/src/interfaces/IPermit2.sol";
import {IStateView} from "v4-periphery/src/interfaces/IStateView.sol";
import {Math} from "openzeppelin-contracts/contracts/utils/math/Math.sol";
import {FullMath} from "@uniswap/v4-core/src/libraries/FullMath.sol";

/**
 * ____________________________
 * Description:
 * @title The Pawn - 100% Immutable, Ownerless, DeFi, Censorship-Resistant
 * @notice The Pawn smart contract performs the following key functions:
 *      1) Collects a 0.25% fee anytime GPX is bought, sold or transferred.
 *      2) Accumulate profits generated by the Pawn in USDC.
 *      3) Every hour:
 *          a) Swaps USDC for GPX
 *          b) Swaps GPX for GPO
 *          c) Swaps GPO for USDC
 * __________________________________
 */
contract Pawn {
    using SafeERC20 for IERC20;
    using SafeCast for uint256;
    using LibPRNG for LibPRNG.PRNG;

    // =======================
    // ======= EVENTS ========
    // =======================

    /**
     * @notice Emitted upon successful completion of the hourly routine.
     * 
     * @dev This routine performs the following operations in sequence:
     *      1. Swaps USDC for GPX via Uniswap V4.
     *      2. Converts GPX into GPO via GPO Vault on a 1:1 basis
     *      3. Swaps GPO for USDC via Uniswap V4 to complete the cycle.
     * 
     * @param gpxPriceBefore The GPX price in USDC before
     * @param usdcIn The amount of USDC used to buy GPX
     * @param gpxOut The amount of GPX received
     * @param gpxPriceAfter The GPX price in USDC after
     * @param gpxIn The amount of GPX exchanged for GPO in the vault
     * @param gpoOut The amount of GPO received from the vault
     * @param gpoIn The amount of GPO sold for USDC
     * @param usdcOut The amount of USDC received from selling GPO
     */
    event HourlyRoutineComplete(
        uint256 gpxPriceBefore,
        uint256 usdcIn, 
        uint256 gpxOut,
        uint256 gpxPriceAfter,
        uint256 gpxIn,
        uint256 gpoOut,
        uint256 gpoIn,
        uint256 usdcOut
    );

    // =================================
    // ========== CONSTANTS ============
    // =================================

    /// @notice Hourly Routine Frequency
    uint256 public constant FREQUENCY = 1 hours;
    /// @dev No Hook Data
    bytes internal constant ZERO_BYTES = bytes("");
        
    // =================================
    // ======= PUBLIC STATE GETTERS ====
    // =================================

    /// @notice GPO
    IERC20 public immutable gpo;
    /// @notice GPX
    IERC20 public immutable gpx;
    /// @notice USDC
    IERC20 public immutable usdc;

    /// @notice GoldPesa Vault Contract
    GPOVault public immutable vault;

    /// @notice GPX Pool Key
    PoolKey public gpxPoolKey;
    /// @notice GPO Pool Key
    PoolKey public gpoPoolKey;

    /// @notice Uniswap V4 State View
    IStateView public immutable stateview;
    /// @notice Uniswap V4 Universal Router
    IUniversalRouter public immutable router;
    /// @notice Permit2
    IPermit2 public immutable permit2;

    // =================================
    // ==== PRIVATE STATE VARIABLES ====
    // =================================

    uint256 private lastExecution;

    // ============================
    // ======== CONSTRUCTOR =======
    // ============================

    /**
     * @notice Initializes the Pawn smart contract with required token addresses, GoldPesa Vault, 
     *         Uniswap pool keys, and supporting contract interfaces.
     * 
     * @param _gpo GPO token address 
     * @param _gpx GPX token address
     * @param _usdc USDC token address
     * @param _vault GPOVault contract used for GPX-GPO conversions
     * @param _gpoPoolKey Uniswap V4 pool key for GPO/USDC
     * @param _gpxPoolKey Uniswap V4 pool key for GPX/USDC
     * @param _stateview Uniswap V4 StateView contract address
     * @param _router Uniswap V4 Universal Router V2 address
     * @param _permit2 Permit2 address used for token approvals
     */
    constructor(
        address _gpo,
        address _gpx,
        address _usdc,
        GPOVault _vault,
        PoolKey memory _gpoPoolKey,
        PoolKey memory _gpxPoolKey,
        address _stateview,
        address _router,
        address _permit2
    ) {

        require(_gpo != address(0) && _gpx != address(0) && _usdc != address(0) && 
            _stateview != address(0) && _router != address(0) && _permit2 != address(0), "Invalid contract address");
        
        gpo = IERC20(_gpo);
        gpx = IERC20(_gpx);
        usdc = IERC20(_usdc);
        vault = _vault;
        gpoPoolKey = _gpoPoolKey;
        gpxPoolKey = _gpxPoolKey;
        stateview = IStateView(_stateview);
        router = IUniversalRouter(_router);
        permit2 = IPermit2(_permit2);
    }

    // ============================
    // ======= MAIN FUNCTIONS =====
    // ============================

    /**
     * @notice Executes the hourly trading routine of the Pawn smart contract.
     * @dev 
     * - This function can only be executed once per hour. It performs a closed-loop strategy:
     *      1. Swaps USDC for GPX via Uniswap V4
     *      2. Converts GPX to GPO via the GPOVault (1:1 swap)
     *      3. Swaps GPO to USDC via Uniswap V4
     * - Pawn profits accumulate in USDC, and re-execution within the same hour is prevented.
     *
     * @notice Emits an HourlyRoutineComplete event with details of the trades executed.
     */
    function hourlyRoutine() external {
        uint256 thisHour = block.timestamp - (block.timestamp % FREQUENCY);

        // Prevent re-execution within the same hour
        if (thisHour == lastExecution) return;

        // Step 1: Swap USDC for GPX
        (uint256 gpxPriceBefore, uint256 usdcIn, uint256 gpxOut, uint256 gpxPriceAfter) = swapUSDCforGPX();

        // Step 2: Swap GPX for GPO
        (uint256 gpxIn, uint256 gpoOut) = swapGPXforGPO();

        // Step 3: Swap GPO for USDC
        (uint256 gpoIn, uint256 usdcOut) = swapGPOforUSDC();

        // Update the last execution time
        lastExecution = thisHour;

        // Emit Hourly Routine Complete Event
        emit HourlyRoutineComplete( 
            gpxPriceBefore,
            usdcIn, 
            gpxOut,
            gpxPriceAfter,
            gpxIn,
            gpoOut,
            gpoIn,
            usdcOut 
        );
    }

    /**
     * @notice Swaps a randomized amount of USDC for GPX via the Uniswap V4 pool.
     * @dev 
     * - Fetches the current square root price and liquidity from the GPX pool.
     * - Estimates a price range (max 0.25% sqrt price change).
     * - Calculates the maximum USDC input allowed.
     * - Selects a pseudorandom USDC amount below the max.
     * - Approves Permit2 for spending the USDC.
     * - Executes the swap through Universal Router.
     *
     * @return gpxPriceBefore The square root price before the swap (sqrtQ96).
     * @return usdcIn The randomly selected USDC amount to swap.
     * @return gpxOut The amount of GPX received from the swap.
     * @return gpxPriceAfter The square root price after the swap (sqrtQ96).
     */
    function swapUSDCforGPX() internal returns (
        uint256 gpxPriceBefore,
        uint256 usdcIn, 
        uint256 gpxOut,
        uint256 gpxPriceAfter
    ) {
        // Fetch GPX square root price X96 Before Swap
        (uint160 sqrtPriceX96Before, , , ) = stateview.getSlot0(gpxPoolKey.toId());

        // Max square root price X96 (1.0025 * sqrtPriceX96)
        uint256 maxSqrtPriceX96 = FullMath.mulDiv(uint256(sqrtPriceX96Before), 10025, 10000);
        
        // Retrieve total active liquidity for the GPX/USDC pool.
        uint128 liquidity = stateview.getLiquidity(gpxPoolKey.toId());

        // Determine the amount of USDC between sqrtPriceX96Before and maxSqrtPriceX96
        uint256 maxUSDCAmount = SqrtPriceMath.getAmount1Delta(
            sqrtPriceX96Before,
            maxSqrtPriceX96.toUint160(),
            liquidity, 
            false
        );

        // Get the minimum between the maxUSDCAmount and the USDC balance inside this contract divided by 1000
        maxUSDCAmount = Math.min(usdc.balanceOf(address(this)) / 1000, maxUSDCAmount);

        // Calculate a pseudorandom USDC amount to swap
        uint256 randomUSDCAmount = getRandomUSDCAmount(maxUSDCAmount);

        // Initialize GPX amount out to zero
        uint256 gpxAmountOut = 0;

        // Swap only if the randomUSDCAmount is greater than zero
        if (randomUSDCAmount > 0) {
            // Approve Permit2 to spend randomUSDCAmount
            approveTokenWithPermit2(
                address(usdc),
                randomUSDCAmount.toUint160(),
                (uint48)(block.timestamp + 300)
            );

            // Calculate the GPX balance before swap 
            uint256 gpxBalanceBeforeSwap = gpx.balanceOf(address(this));

            // Swap USDC to GPX
            swapExactInputSingle(
                gpxPoolKey,
                randomUSDCAmount.toUint128(),
                uint128(0),
                false
            );

            // Calculate the GPX balance after swap
            uint256 gpxBalanceAfterSwap = gpx.balanceOf(address(this));

            // Calculate the amount of GPX received from the swap
            gpxAmountOut = gpxBalanceAfterSwap - gpxBalanceBeforeSwap;
        }

        // Fetch GPX square root price X96 After Swap
        (uint160 sqrtPriceX96After, , , ) = stateview.getSlot0(gpxPoolKey.toId());

        return (
            sqrtPriceX96Before, 
            randomUSDCAmount, 
            gpxAmountOut, 
            sqrtPriceX96After
        );
    }

    /**
     * @notice Generates a pseudorandom USDC amount between 0 and a user-defined maximum.
     * @dev Uses on-chain entropy sources to initialize a PRNG, then selects a value in [0, maxAmountIn).
     *
     * @param maxAmountIn The maximum allowable USDC amount for a single trade.
     * @return randomUSDCAmount A pseudorandom USDC amount between 0 and maxAmountIn.
     */
    function getRandomUSDCAmount(
        uint256 maxAmountIn
    ) internal view returns (uint256 randomUSDCAmount) {
        // Create a pseudorandom seed using multiple entropy sources
        uint256 seed = uint256(
            keccak256(
                abi.encodePacked(
                    block.prevrandao,                      // VRF-like randomness from L1 consensus
                    msg.sender,                            // Caller address
                    gpx.balanceOf(address(this)),          // Current GPX balance in contract
                    usdc.balanceOf(address(this)),         // Current USDC balance in contract
                    block.timestamp                        // Timestamp adds temporal entropy
                )
            )
        );

        // Initialize the PRNG with the generated seed
        LibPRNG.PRNG memory prng;
        prng.seed(seed);

        // Generate a pseudorandom value in the range [0, maxAmountIn)
        randomUSDCAmount = prng.uniform(maxAmountIn);
    }

    /**
     * @notice Converts GPX to GPO via the GPOVault contract on a 1:1 basis.
     * @dev 
     * - Determines the maximum amount of GPX that can be swapped without exceeding the vault's GPO balance.
     * - Approves the vault to spend the selected GPX amount.
     * - Calls the vault's `convertGPOtoGPX` to execute the swap.
     *
     * @return gpxIn The amount of GPX converted.
     * @return gpoOut The amount of GPO received (1:1 conversion).
     */
    function swapGPXforGPO() internal returns (
        uint256 gpxIn,
        uint256 gpoOut
    ) {
        // GPX balance available in this contract
        uint256 gpxBalance = gpx.balanceOf(address(this));

        // Max GPO available for conversion
        uint256 maxGPOAvailable = vault.maxGPOAvailableForConversion();

        // If no GPX Balance or GPO balance in the vault, exit early
        if (gpxBalance == 0 || maxGPOAvailable == 0) {
            return (0,0);
        }

        // Determine the maximum amount to swap (limited by vault's available GPO balance)
        uint256 swapAmount = gpxBalance <= maxGPOAvailable
            ? gpxBalance
            : maxGPOAvailable;

        // Approve the vault to spend the specified amount of GPX
        gpx.approve(address(vault), swapAmount);

        // Execute the conversion in the vault (GPX → GPO)
        vault.convertGPXtoGPO(swapAmount);

        return (swapAmount, swapAmount); // 1:1 conversion
    }

    /**
     * @notice Swaps the contract's GPO balance for USDC via the Uniswap V4 pool.
     * @dev 
     * - Checks if the contract holds any GPO.
     * - Approves Permit2 for the full GPO amount.
     * - Executes the swap through the Universal Router
     *
     * @return gpoIn The GPO balance being swapped
     * @return usdcOut The amount of USDC received from the swap.
     */
    function swapGPOforUSDC() internal returns (
        uint256 gpoIn,
        uint256 usdcOut
    ) {
        // Fetch current GPO balance in this contract
        uint256 gpoBalance = gpo.balanceOf(address(this));

        // If no GPO balance in this contract, exit early
        if (gpoBalance == 0) {
            return (0,0);
        }

        // Approve Permit2 to spend the GPO tokens
        approveTokenWithPermit2(
            address(gpo),
            gpoBalance.toUint160(),
            uint48(block.timestamp + 300)
        );

        // Calculate the USDC balance before swap 
        uint256 usdcBalanceBeforeSwap = usdc.balanceOf(address(this));

        // Swap GPO -> USDC using the Universal Router
        swapExactInputSingle(
            gpoPoolKey,
            gpoBalance.toUint128(),
            uint128(0),
            true
        );

        // Calculate the USDC balance after swap
        uint256 usdcBalanceAfterSwap = usdc.balanceOf(address(this));

        // Calculate the amount of USDC received from the swap
        uint256 usdcAmountOut = usdcBalanceAfterSwap - usdcBalanceBeforeSwap;

        return (gpoBalance, usdcAmountOut); // Return the GPO input and USDC output
    }

    /**
     * @notice Approves a token for Permit2 and authorizes the router to spend a specified amount.
     * @dev 
     * - Sets the ERC20 allowance for the Permit2 contract to the max uint256 value.
     * - Registers the Permit2 approval for the Universal Router to spend a specific amount until expiration.
     *
     * @param token The address of the ERC20 token to approve.
     * @param amount The specific amount to approve via Permit2 (uint160 max).
     * @param expiration The timestamp at which the Permit2 approval expires.
     */
    function approveTokenWithPermit2(
        address token,
        uint256 amount,
        uint48 expiration
    ) internal {
        address spender = address(router); // Universal Router is the spender

        // Grant standard ERC20 approval to Permit2 with unlimited allowance
        if (IERC20(token).allowance(address(this), address(permit2)) < amount) {
            IERC20(token).approve(address(permit2), 0);
            IERC20(token).approve(address(permit2), type(uint256).max);
        }

        // Register Permit2 approval to allow the router to spend the specified amount
        permit2.approve(
            token,
            spender,
            amount.toUint160(), // Permit2 uses uint160 for amount
            expiration          // Permit2 uses uint48 for expiration
        );
    }

    /**
     * @notice Executes a swap of a known input amount for a minimum output amount via the Uniswap V4 Universal Router.
     * @dev 
     * - Encodes the V4 Universal Router command to perform an exact input single swap.
     * - Handles token direction via `zeroForOne` flag.
     * - Performs the swap, settles funds, and takes all outputs.
     *
     * @param key The PoolKey identifying the Uniswap V4 pool (includes tokens, fee, etc.)
     * @param amountIn Exact amount of input token to swap.
     * @param minAmountOut Minimum acceptable amount of output token (used for slippage control).
     * @param zeroForOne Swap direction: true = token0 → token1, false = token1 → token0.
     */
    function swapExactInputSingle(
        PoolKey memory key,
        uint128 amountIn,
        uint128 minAmountOut,
        bool zeroForOne
    ) internal {
        // Encode the Universal Router command
        bytes memory commands = abi.encodePacked(uint8(Commands.V4_SWAP));
        bytes[] memory inputs = new bytes[](1);

        // Encode V4Router actions
        bytes memory actions = abi.encodePacked(
            uint8(Actions.SWAP_EXACT_IN_SINGLE),
            uint8(Actions.SETTLE_ALL),
            uint8(Actions.TAKE_ALL)
        );

        // Prepare parameters for each action
        bytes[] memory params = new bytes[](3);
        params[0] = abi.encode(
            IV4Router.ExactInputSingleParams({
                poolKey: key,
                zeroForOne: zeroForOne,
                amountIn: amountIn,
                amountOutMinimum: minAmountOut,
                hookData: bytes("")
            })
        );

        if (zeroForOne) {
            params[1] = abi.encode(key.currency0, amountIn);
            params[2] = abi.encode(key.currency1, minAmountOut);
        }
        else {
            params[1] = abi.encode(key.currency1, amountIn);
            params[2] = abi.encode(key.currency0, minAmountOut);
        }
       
        // Combine actions and params into inputs
        inputs[0] = abi.encode(actions, params);

        // Execute the swap
        router.execute(commands, inputs, block.timestamp + 300);
    }
}